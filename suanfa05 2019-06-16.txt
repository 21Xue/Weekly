广度优先搜索

图简介
你经常要找出最短 路径，这可能是前往朋友家的最短路径，也可能是国际象棋中把对方将死的最少步数。解决最短 路径问题的算法被称为广度优先搜索。

图是什么
图模拟一组连接。例如，假设你与朋友玩牌，并要模拟谁欠谁钱，可像下面这样指出Alex欠Rama钱。


图1

完整的欠钱图可能类似于下面这样。


图2

Alex欠Rama钱，Tom欠Adit钱，等等。图由节点(node)和边(edge)组成。

图3


就这么简单!图由节点和边组成。一个节点可能与众多节点直接相连，这些节点被称为邻居。 在前面的欠钱图中，Rama是Alex的邻居。Adit不是Alex的邻居，因为他们不直接相连。但Adit既 是Rama的邻居，又是Tom的邻居。


图用于模拟不同的东西是如何相连的。

 广度优先搜索

广度优先搜索是一种用于图的查找算法，可帮助 回答两类问题。

 第一类问题:从节点A出发，有前往节点B的路径吗?

 第二类问题:从节点A出发，前往节点B的哪条路径最短?

假设你经营着一个芒果农场，需要寻找芒果销售商，以便将芒果卖给他。在Facebook，你与 芒果销售商有联系吗?为此，你可在朋友中查找。

这种查找很简单。首先，创建一个朋友名单。

然后，依次检查名单中的每个人，看看他是否是芒果销售商。

假设你没有朋友是芒果销售商，那么你就必须在朋友的朋友中查找。

检查名单中的每个人时，你都将其朋友加入名单。

因此，如果Alice不是芒果销售商，就将其朋友也加入到名单中。 这意味着你将在她的朋友、朋友的朋友等中查找。使用这种算法将搜遍你的整个人际关系网，直 到找到芒果销售商。这就是广度优先搜索算法。

查找最短路径

刚才你看到了如何回答第一类问题，下面来尝试回答第二类问题——谁是关系最近的芒果销 售商。例如，朋友是一度关系，朋友的朋友是二度关系。

在你看来，一度关系胜过二度关系，二度关系胜过三度关系，以此类推。因此，你应先在一 度关系中搜索，确定其中没有芒果销售商后，才在二度关系中搜索。广度优先搜索就是这样做的! 在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查 二度关系。

注意，只有按添加顺序查找时，才能实现这样的目的。有一个可实现这种目的的数据 结构，那就是队列(queue)。

队列

队列的工作原理与现实生活中的队列完全相同。队列类 似于栈，你不能随机地访问队列中的元素。队列只支 持两种操作:入队和出队。

如果你将两个元素加入队列，先加入的元素将在后加入的元素之前出队。因此，你可使用队 列来表示查找名单!这样，先加入的人将先出队并先被检查。

队列是一种先进先出(First In First Out，FIFO)的数据结构，而栈是一种后进先出(Last In First Out，LIFO)的数据结构。

实现图
首先,需要使用代码来实现图。图由多个节点组成。每个节点都与邻近节点相连，散列表能够将键映射到值。在这里，你将要将节点映射到所有邻居。

表示这种映射的代码如下。

graph = {}
graph["you"] = ["alice","bob","claire"]
注意，“you” 被映射到了一个数组，因此graph["you"]是一个数组,其中包含了"you"的所有邻居。

