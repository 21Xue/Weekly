排序

上次我们讲了两个最基本的数据结构。我认为在计算机的世界中，当有了数据结构，也就是存储的方式方法的时候，如果不进行一些操作，其实是没有意义的。

那么既然要变成有意义，就是要操作，那么有什么操作呢？也有两个最基本的操作，那就查找和排序。还有些人说删除，插入，移动之类的，我个人认为，在这些操作之前，你的前置条件就是查找和排序。比如有序的数据结构和无序的数据结构在查找、插入、删除、移动是不同的。

1.排序算法的种类。

基本的排序算法分为：

1.插入排序：
    a.直接插入排序
    b.希尔排序
2.选择排序
    a.简单选择排序
    b.堆排序
3.交换排序
    a.冒泡排序
    b.快速排序
4.归并排序
5.基数排序

以上为最基本的8中排序算法，其他的排序算法都是在这八种方法上的组合与变种。

1.插入排序：

    a.直接插入排序：这个排序方法顾名思义，就是将乱序的元素插入到已经排序好的序列中，那如何做呢？其实非常简单粗暴，就是挨个比较，然后比较完毕后就插入到合适的位置就好了。

    b.希尔排序：这个排序一听这个名字啊，就知道是有一个叫“希尔”的人发明的，这个排序算法是对直接插入排序的改进。首先需要构造一个增量的序列（递减至1），按某个增量d分成若干组子序列，每组中记录的下标相差d，对每组中全部元素进行直接插入排序，然后再用增量序列中下一个较小的增量进行分组，再对每组进行直接插入排序，直至增量为1。这什么意思呢？
        看图所示：有一个10个数的乱序数组，

        一开始设置间隔为5，那么在d为5这个间隔中，就会被分为5组，（0-5）、（1-6）、（2-7）、（3-8）、（4-9）。
        
        这算第一次排序结果，那么就会把这五组进行一次排序。
        
        然后在减少d，比如减少到3。（0-3-6-9）、（1-4-7）、（2-5-8）

        再把这三组进行排序，然后在减少d，直到变成d变成1。

        总结： 希尔排序相比于简单直接插入排序，减少了复制的次数，原因是当增量较大时数据项每一趟排序需要移动的个数很少，尽管数据项的个数很多；当增量减小时，每一趟需要移动的数据增多，但此时已经接近于它们排序后的最终位置，所以希尔排序的效率比插入排序高很多。但是没有快速排序算法快，因此对规模非常大的数据排序不是最优选择。但希尔排序在最坏的情况下和平均情况下执行效率相差不是很多，而快速排序在最坏的情况下执行的效率会非常差。所以，大部分排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法。

2.选择排序：

    a.简单选择排序：

        这个排序算法的思想就是，遍历需要排序的元素，然后找到极值（可以是只找最大、只找最小、最大和最小同时找，一般来说都是最大最小同时找，这样比较快），找到极值以后，把极值和当前所需要排序的位置进行交换。

    b.堆排序
        这个排序算法要需要用到堆的知识。先暂时不讲，等到讲到堆的时候，再一并说一下。

3.交换排序

    a.冒泡排序
        它是最简单的一种交换排序，思想就是不断遍历数组，每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

        冒泡的体现就是和相邻的交换。

    b.快速排序

        我个人认为是所有排序算法中最重要的也是最常用的算法。

        过程如下：
        1）选择一个基准元素,通常选择第一个元素或者最后一个元素；
        2）通过一趟排序将其他元素分别放在基准元素的左右两边，如果升序，那么左边全部都是比基准元素小的，右边全部是比基准元素大的。
        3）此时基准元素在其排好序后的正确位置。这句话怎么理解？这个时候左右两边的元素还是乱序，只有基准元素在它应该在的位置上了。
        4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。

4.归并排序

    说白了就是merge！

    思想是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干有序个子序列，然后再将它们合并为整体有序序列。1 个元素的表总是有序的，所以对n 个元素的待排序列，每个元素可看成1 个有序子表，对子表两两合并生成n/2个子表，所得子表除最后一个子表长度可能为1 外，其余子表长度均为2。再进行两两合并，直到生成n 个元素按关键码有序的表。

5.基数排序

    核心思想：基数排序是一种对关键字进行分配和收集，注意：不进行关键字的比较,而是利用”分配”和”收集”。

    基数排序分为两个：LSD和MSD

    
    
    LSD：Least significant digit

    比如有一串数值： 73, 22, 93, 43, 55, 14, 28, 65, 39, 81

    注意不比较哦，是分配。线按照顺序“分配”个位数。

    0：
    1：81
    2：22
    3：73，93,43
    4：14
    5：55，65
    6：
    7：
    8：28
    9：39

    这个进行一次“收集”！

    变成：81, 22, 73, 93, 43, 14, 55, 65, 28, 39！

    然后在进行一次十位数“分配”

    0：
    1：14
    2：22 28
    3：39
    4：43
    5：55
    6：65
    7：73
    8：81
    9：93

    然后在收集一次：14, 22, 28, 39, 43, 55, 65, 73, 81, 93

    排序结束。

    如果不是数字，还是按照给出的元素的关键字进行收集和分配。
    
    MSD：Most significance digit

    这个就是和LSD反着来，从最高位开始分配，然后进行收集


    比如：15,25,105,78,34,21,32,41

    从百位开始：

    分配：
    
    0：15,25，78,34,21,32,41
    1：105

    这里开始和LSD有些不同，MSD要求当分配的元素个数不是1的时候，对个数不是1的里面进行分配，否则不进行分配了。

    那么百位个数不是1的只有0。对百位为0的进行十位数分配。

    0：
    1：15
    2: 25，21
    3：34，32
    4：41
    5
    6
    7: 78
    8
    9

    然后对十位个数不为1的进行个位数分配。

    最终为排序结果。

具体使用哪一种需要结合具体情况分析。影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，需要考虑的因素有以下四点：（1）待排序的记录数目n的大小；（2）记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；（3）关键字的结构及其分布情况；（4）对排序稳定性的要求。（排序算法的稳定性是指：若待排序的序列中存在多个具有相同关键字的记录，经过排序这些记录的相对次序保持不变，则称该算法是稳定的；若经排序后，记录的相对次序发生了改变，则称该算法是不稳定的。稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序；不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。）
排序算法选取准则：

当n较大，则应采用时间复杂度为O(nlogn)的排序方法：快速排序、堆排序或归并排序序。快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短。
当n较大，内存空间允许，且要求稳定性：归并排序。
当n较小，可采用直接插入或直接选择排序。（当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。）
基数排序是一种稳定的排序算法，但有一定的局限性：（1）关键字可分解；（2）记录的关键字位数较少，如果密集更好；（3）如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。

  













